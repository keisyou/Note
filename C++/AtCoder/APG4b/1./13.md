# N - 1.13.配列

## キーポイント

- **配列**は様々なデータの列を扱うことができる機能
- `vector<型> 配列変数名;` で配列変数を宣言できる
- `配列変数名 = { 要素1, 要素2, ... };` で配列変数に値を代入できる
- `配列変数.at(i)` で i 番目の要素にアクセスできる
- `配列変数.size()` で配列の要素数を取得できる
- `vector<型> 配列変数名(要素数)` と書くと指定した要素数で配列を初期化できる
- 配列で N 個の入力を受け取るときは、N 要素で初期化した後、for 文の中で `at` を使って 1 ずつ受け取る

```c++
vector<int> vec(N);
for (int i = 0; i < N; i++) {
  cin >> vec.at(i);
}
```

- 配列と for 文を組み合わせると、大量のデータを扱うプログラムを簡潔に書ける
- 配列の添字のルールは文字列と同じ

## 配列と文字列

文字列は「文字の列」を扱うための機能でした。\
**配列**は文字だけでなく、様々なデータの列を扱うことができる非常に重要な機能です。

文字列と配列は使い方もある程度同じです。\
次のプログラムは、「`'a'`, `'b'`, `'c'`, `'d'`」という文字の列と、「`25`, `100`, `64`」という整数の列を扱っています。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {

  // 文字列
  string str; // 文字列変数を宣言

  str = "abcd"; // 'a', 'b', 'c', 'd' という文字(char)の列を代入

  cout << str.at(0) << endl; // 1つ目である'a'を出力

  cout << str.size() << endl; // 文字列の長さである4を出力


  // 配列
  vector<int> vec; // int型の配列変数vecを宣言

  vec = { 25, 100, 64 }; // 25, 100, 64 という整数(int)の列を代入

  cout << vec.at(0) << endl; // 1つめである25を出力

  cout << vec.size() << endl; // 配列の長さである3を出力
}
```

**実行結果**

```
a
4
25
3
```

### 配列変数の宣言

配列変数は次の形式で宣言します。

```c++
vector<型> 配列変数名;
```

配列が持つデータの 1 つ 1 つのことを**要素**と呼びます。

`vec = { 25, 100, 64 };` と書いた場合、「25, 100, 64」というデータ列が配列変数 `vec` に代入されています。

### i 番目の要素

文字列と同様に、配列も `.at(i)` を使って i 番目の要素へアクセスできます。

```c++
配列変数.at(i)
```

配列でも添字は 0 から始まります。

`vector<int> vec = {25, 100, 64};` という配列変数 `vec` の場合、添字の値と文字の対応は次の表のとおりです。

|          |     |     |     |
| -------- | --- | --- | --- |
| **添字** | 0   | 1   | 2   |
| **要素** | 25  | 100 | 64  |

### 配列の要素数

文字列と同様に、配列も `.size()` を使って要素数（長さ）を取得できます。

```c++
配列変数.size()
```

`vector<int> vec = {25, 100, 64};` という配列変数 `vec` の場合、`vec.size()` の値は `3` になります。

## 配列と変数

配列は「複数の変数を一度に宣言する方法」のように使うことができます。

次のプログラムは、3 つの整数を入力から受け取り、それらの合計を出力します。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
  int a1, a2, a3;
  cin >> a1 >> a2 >> a3;

  cout << a1 + a2 + a3 << endl;
}
```

次のプログラムは上のプログラムとほとんど同じ意味です。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
  // 3個の入力を受け取れるように 3要素の配列 {0, 0, 0} で初期化
  vector<int> vec(3);

  // atを使って1つずつ入力
  cin >> vec.at(0) >> vec.at(1) >> vec.at(2);

  // 和を出力
  cout << vec.at(0) + vec.at(1) + vec.at(2) << endl;
}
```

### 配列の初期化

次のように書くと、指定した要素数で配列を初期化できます。

```c++
vector<型> 配列名(要素数);
```

`vector<int> vec(3);` は `vector<int> vec = {0, 0, 0}` とほとんど同じ意味です。

`vector<int>` の場合は全ての要素が `0` で初期化されます。\
どんな値で初期化されるかは型によって変わります。例えば `vector<string> vec(3)` と書いた場合、空の文字列の配列 `{"", "", ""}` で初期化されます。

### 配列変数への入力

配列変数で入力を受け取るには、十分な大きさで配列を初期化した後、`.at(i)` を使って一つずつ受け取っていく必要があります。

```c++
// 3個の入力を受け取れるように 3要素の配列 {0, 0, 0} で初期化
vector<int> vec(3);

// atを使って1つずつ入力
cin >> vec.at(0) >> vec.at(1) >> vec.at(2);
```

**for 文を使った入力**

入力を配列変数で受け取る場合、for 文を使って入力処理を書くのが一般的です。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
  // 100要素の配列で初期化
  vector<int> vec(100);

  // 100個の入力を受け取る
  for (int i = 0; i < 100; i++) {
    cin >> vec.at(i);
  }

}
```

入力の個数が多いときでも、for 文を使えば簡潔に入力処理を書くことができます。

## 配列の使い所

配列と for 文を組み合わせると、大量のデータを扱うプログラムを書くことができます。\
次の例題を見て下さい。

### 例題

N 人の数学と英語のテストの点数が与えられます。\
それぞれの人について、数学と英語の点数の合計点を計算してください。

**制約**

0 ≦ N ≦ 1000

**入力**

```
N
1人目の数学の点数 2人目の数学の点数 ... N人目の数学の点数
1人目の英語の点数 2人目の英語の点数 ... N人目の英語の点数
```

**出力**

```
1人目の数学と英語の合計点
2人目の数学と英語の合計点
⋮
N人目の数学と英語の合計点
```

**入力例**

```
3
20 100 30
100 5 40
```

**出力例**

```
120
105
70
```

### 解答例

N が小さい場合、配列を使わずに int 型の変数だけでこの問題を解くことも可能です。\
しかし、N が大きい場合は配列を使わずに書くのは非常に大変になります。\
例えば N=1000 だったとき、変数を 1000 個宣言しなければなりません。

配列と for 文を使えば、N の大きさに関わらず簡潔に処理を書くことができます。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
  int N;
  cin >> N;

  vector<int> math(N); // N個の数学の点数データ
  vector<int> english(N); // N個の英語の点数データ

  // 数学の点数データを受け取る
  for (int i = 0; i < N; i++) {
    cin >> math.at(i);
  }

  // 英語の点数データを受け取る
  for (int i = 0; i < N; i++) {
    cin >> english.at(i);
  }

  // 合計点を出力
  for (int i = 0; i < N; i++) {
    cout << math.at(i) + english.at(i) << endl;
  }
}
```

## その他の機能

### 初期値の設定

次のように書くと、配列の各要素の初期値を指定できます。

```c++
vector<型> 配列名(要素数, 初期値);
```

例えば `vector<int> vec(3, 5);` と書いた場合、配列変数 `vec` は `{5, 5, 5}` で初期化されます。

### 要素の追加

配列は文字列のように `+=` で要素を追加することはできません。\
代わりに `配列変数.push_back` を使えば、配列の末尾に要素を追加することができます。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
  vector<int> vec = { 1, 2, 3 };

  vec.push_back(10); // 末尾に10を追加

  // vecの全要素を出力
  for (int i = 0; i < vec.size(); i++) {
    cout << vec.at(i) << endl;
  }
}
```

**実行結果**

```
1
2
3
10
```

`push_back` の後の配列変数 `vec` は次の表の通りになっています。

|          |     |     |     |     |
| -------- | --- | --- | --- | --- |
| **添字** | 0   | 1   | 2   | 3   |
| **要素** | 1   | 2   | 3   | 10  |

## 注意点

### 範囲外エラー

文字列と同様に、配列も添字の値が正しい範囲内に無いと実行時エラーになります。

次のプログラムは `{ 1, 2, 3 }` という 3 要素の配列（有効な添字の値は `0 ～ 2`）に対し、`vec.at(10)` で存在しない要素にアクセスしようとしているため、実行時エラーが発生します。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
  vector<int> vec = { 1, 2, 3 };
  cout << vec.at(10) << endl;
}
```

**実行時エラー**

```
terminate called after throwing an instance of 'std::out_of_range'
  what():  vector::_M_range_check: __n (which is 10) >= this->size() (which is 3)
```

**終了コード**

```
134
```

文字列と同様に、1 行目の最後で `'std::out_of_range'（範囲外）` というエラーメッセージが表示されます。\
2 行目の `__n (which is 10) >= this->size() (which is 3)` では、「添字の値(`10`) ≧ 配列のサイズ(`3`)」であるためエラーが発生したということを伝えています。

## 細かい話

### vector 以外の配列

C++には vector 以外にも配列の書き方があります。次の 3 つの配列の書き方はほとんど同じ意味です。

```c++
vector<int> data(3); // vectorによる配列
int data[3]; // Cの配列
array<int, 3> data; // arrayによる配列
```

他の人のソースコードを見ると、2 つ目の書き方をよく見かけるかもしれません。\
しかし、この書き方で宣言した配列は多くの落とし穴があります。基本的には vector による配列を使った方が良いです。

### at を使わない i 番目の要素へのアクセス

今まで配列の要素を指定するときは `配列変数.at(添字)` と書いてきましたが、`配列変数[添字]` でも同じことができます。\
ただし、この書き方は範囲外の添字を指定してしまったときにエラーメッセージを表示してくれず、何が原因でプログラムが正しく動いていないのかがわかりにくいので、**`配列変数.at(添字)`の書き方を使うようにしましょう。**

次のプログラムは、配列 `{ 1, 2, 3 }` の最初の要素に 2 つの方法でアクセスしています。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
  vector<int> vec = { 1, 2, 3 };

  cout << vec.at(0) << endl;
  cout << vec[0] << endl; // .at(0)と同じ
}
```

**実行結果**

```
1
1
```

### 安全に [] で i 番目の要素へアクセスする方法

ABC/ARC で他の人の提出を見ると `[]` を使っている人が多いです。これは `[]` のほうが短くて読み書きしやすい、または最初に `[]` を学んで慣れているという理由からです。\
先に述べたとおり `[]` はエラーが発見しにくいですが、`#define _GLIBCXX_DEBUG` とコードの最初に書くことで `.at` と同程度に安全に使うことができるようになります。

2021/11/10 追記　注意：`_GLIBCXX_DEBUG` を使用することで、後に登場する `priority_queue` など、一部の処理の実行速度が遅くなってしまうことが確認されています。使用の際はご注意ください。

次のプログラムは `{ 1, 2, 3 }` という 3 要素の配列（有効な添字の値は `0` ～ `2`）に対し、`vec[10]` で存在しない要素にアクセスしようとしているため、実行時エラーが発生します。

```c++
#define _GLIBCXX_DEBUG
#include <bits/stdc++.h>
using namespace std;

int main() {
  vector<int> vec = { 1, 2, 3 };
  cout << vec[10] << endl; // 実行時エラーが起きる
}
```

**実行時エラー**

```
/usr/include/c++/5/debug/vector:409:
Error: attempt to subscript container with out-of-bounds index 10, but
container only holds 3 elements.

Objects involved in the operation:
    sequence "this" @ 0x0x401350 {
      type =
```

`Error: attempt to subscript container with out-of-bounds index 10, but container only holds 3 elements.` で 3 要素の配列に対して境界外の添字 10 でアクセスしようとしたことを表しています。

`.at()` を使うか `#define _GLIBCXX_DEBUG` ＋ `[]` を使うかは好みですが、APG4b では `.at()` を統一して使用します。

`#define _GLIBCXX_DEBUG` は GCC 特有の機能です。Clang 環境では代わりに `#define _LIBCPP_DEBUG 0` と書く必要があります。

### 要素の削除

`配列変数.pop_back` を使えば配列の末尾の要素を削除することもできます。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
  vector<int> vec = { 1, 2, 3 };

  vec.pop_back(); // 末尾の要素を削除

  // vecの全要素を出力
  for (int i = 0; i < vec.size(); i++) {
    cout << vec.at(i) << endl;
  }
}
```

**実行結果**

```
1
2
```

`pop_back` の後の配列変数 `vec` は次の表の通りになっています。

|          |     |     |
| -------- | --- | --- |
| **添字** | 0   | 1   |
| **要素** | 1   | 2   |

### 配列同士の比較

配列変数同士は `==` で比較することができます。\
`==` では 2 つの配列の全要素が一致していたとき、条件式は真になります。

ただし、比較する際はどちらも「配列変数」である必要があり、`vec == { 1, 2, 3 }` のようには書けないことに注意しましょう。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
  vector<int> vec1 = { 1, 2, 3 };
  vector<int> vec2 = { 1, 2, 3 };

  if (vec1 == vec2) {
    cout << "OK" << endl;
  }

  /*
  ↓これはコンパイルエラーになる
  if (vec1 == { 1, 2, 3 }) {
    cout << "NG" << endl;
  }
  */
}
```

### 配列の初期化 その２

配列の初期化は次のように書くこともできます。

```c++
vector<型> 配列変数 = vector<型>(要素数, 初期値);
```

この書き方はすでに宣言してある配列変数を上書きするときにも使えます。\
次の例では `{10, 10, 10}` で初期化してある変数を 100 要素の配列 `{2, 2, ... , 2, 2}` で上書きしています。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
  vector<int> vec(3, 10); // {10, 10, 10} で初期化
  vec = vector<int>(100, 2); // 100要素の配列 {2, 2, ... , 2, 2} で上書き
  cout << vec.at(99) << endl;
}
```

**実行結果**

```
2
```

### 大きすぎる配列

配列の要素数が多すぎると、実行時エラーになることがあります。\
次の例は要素数が 10 億の配列を確保しようとして実行時エラーが発生しています。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
  vector<int> v(1000000000);
  cout << v[0] << endl;
}
```

**終了コード**

```
134
```

どの程度までの大きさの配列が確保できるかは実行環境によります。

## 資料

[N - 1.13.配列](https://atcoder.jp/contests/apg4b/tasks/APG4b_n)
